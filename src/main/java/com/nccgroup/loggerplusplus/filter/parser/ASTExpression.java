/* Generated By:JJTree: Do not edit this line. ASTExpression.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.nccgroup.loggerplusplus.filter.parser;

import com.nccgroup.loggerplusplus.filter.LogicalOperator;

public
class ASTExpression extends SimpleNode {

    boolean inverse = false;
    LogicalOperator op;

    public ASTExpression(int id) {
        super(id);
    }

    public ASTExpression(FilterParser p, int id) {
        super(p, id);
    }

    @Override
    public String getFilterString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < this.children.length; i++) {
            String childString = this.children[i].getFilterString();
            if (this.children[i] instanceof ASTExpression && !((ASTExpression) this.children[i]).inverse)
                sb.append("(" + childString + ")");
            else
                sb.append(childString);

            if (i != this.children.length - 1) {
                sb.append(" " + op.getLabel() + " ");
            }
        }

        if (inverse) return "!(" + sb.toString() + ")";
        else return sb.toString();
    }

    public LogicalOperator getLogicalOperator() {
        return op;
    }

    public void addCondition(ASTExpression comparison){
        jjtAddChild(comparison, this.jjtGetNumChildren());
    }

    public void addCondition(ASTComparison comparison){
        jjtAddChild(comparison, this.jjtGetNumChildren());
    }

    @Override
    public String toString() {
        return String.format("ASTExpression[inverse=%s, op=%s]", inverse, op);
    }

    /**
     * Accept the visitor.
     **/
    public Object jjtAccept(FilterParserVisitor visitor, VisitorData data) {
        return visitor.visit(this, data);
    }
}
/* JavaCC - OriginalChecksum=f3e2fc4905864ee71fff41d667f32963 (do not edit this line) */
