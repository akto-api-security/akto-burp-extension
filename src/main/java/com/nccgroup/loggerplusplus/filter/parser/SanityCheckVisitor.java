/* Generated By:JavaCC: Do not edit this line. FilterParserDefaultVisitor.java Version 7.0.2 */
package com.nccgroup.loggerplusplus.filter.parser;

import com.nccgroup.loggerplusplus.filter.ComparisonOperator;
import com.nccgroup.loggerplusplus.logentry.LogEntryField;

import java.util.Collection;
import java.util.Date;
import java.util.regex.Pattern;

public class SanityCheckVisitor implements FilterParserVisitor{

  public VisitorData defaultVisit(SimpleNode node, VisitorData data){
    node.childrenAccept(this, data);
    return data;
  }
  public VisitorData visit(SimpleNode node, VisitorData data){
    return defaultVisit(node, data);
  }

  public VisitorData visit(SimpleNode node){
    return visit(node, new VisitorData());
  }

  public VisitorData visit(ASTExpression node, VisitorData data){
    return defaultVisit(node, data);
  }
  public VisitorData visit(ASTComparison node, VisitorData visitorData) {
    defaultVisit(node, visitorData);

    Class leftType, rightType;
    leftType = (node.left instanceof LogEntryField) ? ((LogEntryField) node.left).getType() : node.left.getClass();
    rightType = (node.right instanceof LogEntryField) ? ((LogEntryField) node.right).getType() : node.right.getClass();
    if (leftType == null || rightType == null) return visitorData;

    if (node.comparisonOperator == ComparisonOperator.LESS_THAN || node.comparisonOperator == ComparisonOperator.LESS_THAN_EQUAL
            || node.comparisonOperator == ComparisonOperator.GREATER_THAN || node.comparisonOperator == ComparisonOperator.GREATER_THAN_EQUAL) {
      boolean valid = (Date.class.isAssignableFrom(leftType) || Date.class.isAssignableFrom(rightType))
              || (Number.class.isAssignableFrom(leftType) && Number.class.isAssignableFrom(rightType));
      if (!valid) {
        visitorData.addError(String.format("Operator %s cannot be used to compare groups of type %s and %s.",
                node.comparisonOperator, leftType.getTypeName(), rightType.getTypeName()));
      }
    } else if (node.left instanceof Pattern) {
      visitorData.addError("The left operand of a comparison cannot be a pattern.");
    } else if (node.right instanceof Pattern && !String.class.isAssignableFrom(leftType)) {
      visitorData.addError("Regular expressions can only be used on string elements.");
    } else if (node.comparisonOperator == ComparisonOperator.CONTAINS && !(String.class.isAssignableFrom(leftType) && String.class.isAssignableFrom(leftType))) {
      visitorData.addError("The CONTAINS operator can only be used on string elements.");
    } else if (node.comparisonOperator == ComparisonOperator.IN && Collection.class.isAssignableFrom(rightType)) {
      visitorData.addError("The IN operator requires the right-hand object of the comparison to be a collection (e.g. list, set)!");
    }

    return visitorData;
  }

  @Override
  public VisitorData visit(ASTAlias node, VisitorData data) {
    return data;
  }
}
/* JavaCC - OriginalChecksum=b30458d637879c9662107beea18204f0 (do not edit this line) */
